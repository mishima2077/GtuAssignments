7
D code 1704712925 3
F fahrenheit.c 1704712949 135
#include <stdio.h>

int main(void)
{
	int c;
	printf("Celcius: ");
	scanf("%i",&c);
	printf("Fahrenheit: %i\n",9*c/5+32);
	return 0;
}

F biggest.c 1704712964 207
#include <stdio.h>

int main()
{
	int numbers[] = {31,2,113,4,32,6,7,8};
	int a;
	int b = numbers[0];
	for(int i=0 ; i<8 ; i++)
	{
		int a = numbers[i];
		if(a>b)
		b = a;
	}
	printf("%i\n",b);
	return 0;
}

D java 1704712984 1
F hello.java 1704713011 116
public class hello{
    public static void main(String[] args){
        System.out.println("Hello, World!");
    }
}
L helloLink 1704713037 /code/java/hello.java
L javaDir 1704713054 /code/java
D sourceCode 1704713711 2
F main.cpp 1704713736 87
#include "src/shell.h"

int main(){
    GTUFile::Shell myShell;

    myShell.Start();
}
D src 1704713744 4
F file.cpp 1704713763 4378
#include "file.h"
#include <iostream>
#include <iomanip>

namespace GTUFile{

File::File(const std::string& _name, const std::time_t c_time)
        :name(_name),creationTime(c_time),size(0)
{
    /*Left blank intentionally*/
}

std::string File::formattedTime()const {
    char res[50];
    strftime(res,50,"%b %d %H:%M",localtime(&creationTime));
    return res;
}

dataFile::dataFile(const std::string& _name, const std::vector<char>& _data,const std::time_t c_time):
        File(_name,c_time),data(_data)
{
    size = calc_size();
}

void dataFile::printInfo(std::ostream& out)const{
    out << "F " << std::left << std::setw(20) << getName() << formattedTime() << " "
        << getSize() << " Bytes";
}

void dataFile::printContent(std::ostream& out)const{
        for(const auto& p : data)
            out << p;
}

int dataFile::getSize()const{
    return size;
}

int dataFile::calc_size()const{
    return sizeof(char) * data.size();
}

Directory::Directory(const std::string& _name,Directory* _upper,const std::time_t c_time):
                File(_name,c_time),upperDir(_upper)
{
    /*Left blank intentionally*/
}

Directory::~Directory(){
    for(int i = 0; i < fileCount(); ++i)
        delete files[i];
}

void Directory::printInfo(std::ostream& out)const{
    out << "D " << std::left << std::setw(20) << getName() << formattedTime();
}

void Directory::printContent(std::ostream& out)const{
    for(int i = 0; i < files.size(); ++i){
        files[i]->printInfo(out);
        out << std::endl;
    }
}

void Directory::addContent(File* f){
    size += f->getSize();
    files.push_back(f);
}

void Directory::deleteContent(int ind){
    if(ind < 0 || ind >= fileCount())
        return;

    size -= files[ind]->getSize();
    delete files[ind];
    files.erase(files.begin() + ind);
}

int Directory::getIndex(const std::string& fName)const{
    for(int i = 0; i < fileCount(); ++i)
        if(files[i]->getName() == fName)
            return i;
    return -1;
}

File* Directory::at(int i)const{
    if(i >= 0 && i < fileCount())
        return files[i];
    return nullptr;
}

File* Directory::find(const std::string& fName)const{
    for(int i = 0; i < fileCount(); ++i)
        if(files[i]->getName() == fName)
            return files[i];
    return nullptr;
}

File* Directory::generalFind(const std::string& fPath ,Directory* root){
    std::vector<std::string> parsedPath = Directory::parsePath(fPath);
    Directory* pathFollower = root;

    for(int i = 0; i < parsedPath.size()-1; ++i){        /*This loop travels the path given by the user to*/
                                                         /*find the file that will be link*/
        if(pathFollower->find(parsedPath[i]) != nullptr && dynamic_cast<Directory*>(pathFollower->find(parsedPath[i])) != nullptr)
            pathFollower = dynamic_cast<Directory*>(pathFollower->find(parsedPath[i]));
        else    
            return nullptr;
    }

    File* linkCandidate = pathFollower->find(parsedPath[parsedPath.size()-1]);
    return linkCandidate;
}

std::vector<std::string> Directory::parsePath(const std::string& path){
    std::vector<std::string> res;
    std::string temp = "";

    for(int i = 0; i < path.size(); ++i){
        if(path[i] != '/')
            temp += path[i];
        else{
            if(temp != ""){
                res.push_back(temp);
                temp.clear();
            }
        }
    }
    res.push_back(temp);
    return res;
}

Link::Link(const std::string& _name,const std::string& _path ,Directory* _root,std::time_t ctime)
        :File(_name,ctime),path(_path),root(_root)
{
    /*Left blank intentionally*/
}

void Link::printInfo(std::ostream& out)const{
    out << "L " << std::left << std::setw(20) << getName() << formattedTime();
}

void Link::printContent(std::ostream& out)const{
    File* linkedFile = Directory::generalFind(path,root);
    if(linkedFile == nullptr){
        out << "Linked file does not exist";
        return;
    }

    linkedFile->printContent();
}

File* Link::getLink()const{
    File* linkedFile = Directory::generalFind(path,root);
    Link* linkTest = dynamic_cast<Link*>(linkedFile);

    if(linkedFile!=nullptr && linkTest != nullptr) /*If the linked file is another link, it follows the link to get the main file*/
        return linkTest->getLink();
    else
        return linkedFile;
}

} //GTUFile
F file.h 1704713769 5079
#ifndef FILE_H
#define FILE_H
#include <iostream>
#include <string>
#include <ctime>
#include <vector>

namespace GTUFile{

class File{ //Abstract File class
public:
    File(const std::string& _name, const std::time_t c_time = time(0));
    
    virtual void printInfo(std::ostream& out = std::cout)const = 0;
    /*Prints out information about the file*/
    virtual void printContent(std::ostream& out = std::cout)const = 0;
    /*Prints the contents of the file*/

    void setName(const std::string& _name) {name = _name;}
    int getSize()const {return size;}
    std::string getName()const {return name;}
    std::time_t getTime()const {return creationTime;}
    std::string formattedTime()const;
    //Returns the creation time in a formatted way, the format:
    //Mmm Ddd hh::mm

    //Default big three is fine
    virtual ~File()
    {/*Left blank intentionally*/}
private:
    std::string name;
    std::time_t creationTime;
protected:
    int size;
};

class dataFile : public File{
public:
    dataFile(const std::string&, const std::vector<char>&,const std::time_t c_time = time(0));

    virtual void printInfo(std::ostream& out = std::cout)const override;
    virtual void printContent(std::ostream& out = std::cout)const override;

    int getSize()const;
    std::vector<char> getData()const{return data;}

    //Default big three is fine

    //Iterator class for the dataFile
    class Iterator{
    public:
        Iterator(const dataFile& _file, int _ind = 0) : file(_file), ind(_ind)
        {/*Left blank intentionally*/}

        Iterator& operator++() {
            ++ind;
            return *this;
        }

        bool operator==(const Iterator& o)const{return (ind == o.ind && &file == &o.file);}
        bool operator!=(const Iterator& o)const{return !(*this == o);}

        char operator*() const {return file.data[ind];}
    private:
        const dataFile& file;
        int ind;
    };

    Iterator begin()const{
        return Iterator(*this, 0);
    }

    Iterator end()const{
        return Iterator(*this, data.size());
    }
private:
    std::vector<char> data;

    int calc_size()const;
};

class Directory : public File{ 
public:
    Directory(const std::string&, Directory* _upper = nullptr,const std::time_t c_time = time(0));

    virtual void printInfo(std::ostream& out = std::cout)const override;
    virtual void printContent(std::ostream& out = std::cout)const override;

    void addContent(File* f);
    void deleteContent(int ind);

    int getIndex(const std::string& fname)const; 
    /*Returns the index of the file by the given name on the directory*/
    /*Returns -1 if the file is not on the directory*/

    File* at(int i)const;

    File* find(const std::string& fName)const; 
    /*Find a file within itself*/
    static File* generalFind(const std::string& fPath ,Directory* root); 
    /*Find a file from a path within given directory*/

    Directory* getUpper()const {return upperDir;}
    void setUpper(Directory* d) {upperDir = d;}

    int fileCount()const {return files.size();}

    Directory(const Directory& src) = delete;
    Directory& operator=(const Directory& src) = delete;
    /*Implementing copy and assignment operations would require the knowledge
      of all of the classes that are inherited from abstract File class. To make 
      it suitable for further development, I decided not to implement them.*/

    virtual ~Directory();    

    //Iterator class for Directory
    class Iterator{
    public:
        Iterator(Directory& _file, size_t _ind = 0) : file(_file), ind(_ind) 
        {/*Left blank intentionally*/}

        Iterator& operator++() {
            ++ind;
            return *this;
        }

        bool operator==(const Iterator& o)const{return (ind == o.ind && &file == &o.file);}
        bool operator!=(const Iterator& o)const{return !(*this == o);}

        File* operator*()const{return file.at(ind);}
    private:
        const Directory& file;
        int ind;
    };

    Iterator begin(){
        return Iterator(*this, 0);
    }

    Iterator end(){
        return Iterator(*this, files.size());
    }
private:
    std::vector<File*> files;
    Directory* upperDir;

    static std::vector<std::string> parsePath(const std::string&);
};

class Link : public File{
public:
    Link(const std::string& _name ,const std::string& _path,Directory* _root, std::time_t ctime = time(0));

    virtual void printInfo(std::ostream& out = std::cout)const override;
    virtual void printContent(std::ostream& out = std::cout)const override;

    File* getLink()const;
    std::string getPath()const{return path;}

    //Default big three is fine

    /*An Iterator class for Link was not feasible, because it would have to behave differently
      according to the file that it has been linked. Those can be a dataFile, a directory and 
      a link. Because of the nature of the link, there is nothing to iterate from, thats why
      I didn't implement an Iterator class for the Link.*/
private:
    std::string path;
    Directory* root;
};

}//GTUFile


#endif
F shell.cpp 1704713782 13495
#include "shell.h"
#include "file.h"
#include <string>
#include <stdexcept>
#include <fstream>

namespace GTUFile{

Shell::Shell():root("."),currentDir(&root),totalSize(0){
    try{
        initialize();
    }
    catch(const std::exception& e){
        std::cout << "No previous shell has been found, creating a new shell.\n";
    }
}

Shell::~Shell(){
    try{
        saveShell();
    }
    catch(const std::exception& e){
        std::cout << "Shell saving has failed, terminating the program without saving.\n";
    }
}

void Shell::Start(){
    Shell::openingScreen();

    std::vector<std::string> input;
    do{
        try{
            std::cout << ">";

            input.clear();
            Shell::parseInput(input);

            commandSeperator(input);
        }
        catch(const std::exception& e){
            std::cout << "Exception: " << e.what() << std::endl;
        }
    }while(input[0] != "exit");
}

void Shell::commandSeperator(const std::vector<std::string>& input){
    if(input.size() == 0)
        throw std::invalid_argument("Invalid command");

    if(input[0] == "mkdir")
        mkdir(input);

    else if(input[0] == "ls")
        ls(input);

    else if(input[0] == "cd")
        cd(input);

    else if(input[0] == "cp")
        cp(input);

    else if(input[0] == "cat")
        cat(input);

    else if(input[0] == "rm")
        rm(input);

    else if(input[0] == "link")
        link(input);
    else if(input[0] == "pwd")
        pwd(input);
}

void Shell::mkdir(const std::vector<std::string>& input){
    if(input.size() == 1)
        throw std::invalid_argument("No name given to the directory");

    if(input.size() != 2)
        throw std::invalid_argument("Invalid argument given to command mkdir");

    if(currentDir->find(input[1]) != nullptr)
        throw std::invalid_argument("Can't have files with same names in a directory");
    
    Directory* tempD = new Directory(input[1],currentDir);
    currentDir->addContent(tempD);
}

void Shell::ls(const std::vector<std::string>& input)const{
    if(input.size()==1){
        std::cout << "D " << std::left << std::setw(20) << "." << currentDir->formattedTime() << std::endl;
        if(currentDir->getUpper() != nullptr)
            std::cout << "D " << std::left << std::setw(20) << ".." << currentDir->getUpper()->formattedTime() << std::endl;
        
        currentDir->printContent();
    }
    else if(input.size()==2 && input[1] == "-R"){
        lsRecursive(currentDir);
    }
    else
        throw std::invalid_argument("Invalid argument given to command ls");
}

void Shell::lsRecursive(const Directory* d,int depth)const{
    for(int i = 0; i < d->fileCount(); ++i){
        for(int j = 0; j < depth; ++j) /*Spacing according to the depth*/
            std::cout << "    ";

        d->at(i)->printInfo();
        std::cout << "\n";
        if(dynamic_cast<Directory*>(d->at(i))!=nullptr)
            lsRecursive(dynamic_cast<Directory*>(d->at(i)),depth + 1);
    }
}

void Shell::cd(const std::vector<std::string>& input){
    if(input.size() != 2)
        throw std::invalid_argument("Invalid argument given to command cd");

    if(input[1] == "/")
        currentDir = &root;
    else if(input[1] == ".." && currentDir->getUpper() != nullptr)
        currentDir = currentDir->getUpper();
    else{
        File* temp = currentDir->find(input[1]);

        Directory* tempD = dynamic_cast<Directory*>(temp); /*Checks if the said file is a directory*/
        if(tempD != nullptr){
            currentDir = tempD;
            return;
        }

        Link* tempL = dynamic_cast<Link*>(temp); /*Checks if the said file is a link linked to a directory*/
        if(tempL != nullptr && dynamic_cast<Directory*>(tempL->getLink()) != nullptr){
            currentDir = dynamic_cast<Directory*>(tempL->getLink());
            return;
        }
    }
}

void Shell::cp(const std::vector<std::string>& input){
    if(input.size() != 3)
        throw std::invalid_argument("Invalid argument given to command cp");

    if(currentDir->find(input[2]) != nullptr)
        throw std::invalid_argument("Can't have files with same names in a directory");
    
    File* newFile;
    std::string path = input[1];
    if(path[0] != '/') /*This part changes the local path to a complete path*/
        path = completePath(path);
    File* targetFile = Directory::generalFind(path,&root);

    std::ifstream ifile;
    ifile.open(input[1]);
    if(ifile.is_open()){ /*Program priorities the OS to shell copy, checks it first.
                           If it can't find it on the OS, program then tries to find
                           the file at its shell.*/
        std::vector<char> _data;
        char byte;
        while(ifile.get(byte))
            _data.push_back(byte);
        newFile = new dataFile(input[2],_data);
        ifile.close();
    }
    else if(targetFile != nullptr){
        if(dynamic_cast<dataFile*>(targetFile)!=nullptr)
            newFile = new dataFile(*dynamic_cast<dataFile*>(targetFile));
        else if(dynamic_cast<Link*>(targetFile)!=nullptr)
            newFile = new Link(*dynamic_cast<Link*>(targetFile));
        else if(dynamic_cast<Directory*>(targetFile)!=nullptr){
            newFile = new Directory(input[2],currentDir);
            copyDir(dynamic_cast<Directory*>(newFile),dynamic_cast<Directory*>(targetFile));
        }
        newFile->setName(input[2]);
    }
    else
        throw std::invalid_argument("Failed to find the file");

    /*Checks if there is enought space for the new file on the disk*/
    int newSize = totalSize + newFile->getSize();
    if(newSize > 10000000){
        delete newFile;
        throw std::overflow_error("Not enough space in the disk");
    }
    totalSize = newSize;
    
    currentDir->addContent(newFile);
}

void Shell::cat(const std::vector<std::string>& input)const{
    if(input.size() != 2)
        throw std::invalid_argument("Invalid argument given to command cat");

    File* temp = currentDir->find(input[1]);
    if(temp == nullptr)
        throw std::invalid_argument("File has not been found");

    if(dynamic_cast<Directory*>(temp) != nullptr)
        throw std::invalid_argument(input[1] + " is a directory");

    Link* linkCheck = dynamic_cast<Link*>(temp);
    if(linkCheck != nullptr)
        if(dynamic_cast<Directory*>(linkCheck->getLink()))
            throw std::invalid_argument(input[1] + " is linked to a directory");

    temp->printContent();
    std::cout << std::endl;
}

void Shell::rm(const std::vector<std::string>& input){
    if(input.size() != 2)
        throw std::invalid_argument("Invalid argument given to command rm");

    int ind = currentDir->getIndex(input[1]);
    if(ind == -1)
        throw std::invalid_argument("This directory don't have a file named " + input[1]);

    totalSize -= currentDir->at(ind)->getSize();
    currentDir->deleteContent(ind);
}

void Shell::link(const std::vector<std::string>& input){
    if(input.size() != 3)
        throw std::invalid_argument("Invalid argument given to command link");

    std::string path = input[1];
    if(path[0] != '/') /*If the user has given a local path, starting from the current directory, we need to complete it*/
                       /*before sending it to the link. Paths must start from the root for the links*/
        path = completePath(std::move(path));

    Link* linkCandidate = new Link(input[2],path,&root);
    if(linkCandidate->getLink() == nullptr){
        delete linkCandidate;
        throw std::invalid_argument("Invalid path or file");
    }

    currentDir->addContent(linkCandidate);   
}

void Shell::pwd(const std::vector<std::string>& input)const{
    if(input.size() != 1)
        throw std::invalid_argument("Invalid argument given to command pwd");

    std::cout << completePath() << std::endl;
}

void Shell::parseInput(std::vector<std::string>& v){
    std::string temp;
    do{
        std::cin >> temp;
        v.push_back(temp);
    }while(getchar() != '\n');
}

std::string Shell::nameFromPath(const std::string& path){ 
    std::string name_reversed;
    std::string name;

    //UPDATE TO ITERATOR
    for(int i = path.size() - 1; i >= 0; --i){
        if(path[i] != '/')
            name_reversed.push_back(path[i]);
        else 
            break;
    }
    for(int i = name_reversed.size()-1; i >= 0; --i)
        name.push_back(name_reversed[i]);

    return name;
}

std::string Shell::completePath(const std::string& path)const{
    Directory* dirFollower = currentDir;
    std::vector<std::string> reversedRes;
    std::string res = "";
    while(dirFollower != &root){
        reversedRes.push_back(dirFollower->getName());
        dirFollower = dirFollower->getUpper();
    }

    for(auto p = reversedRes.rbegin(); p != reversedRes.rend(); ++p){
        res += '/';
        res += *p;
    }
    if(path != ""){
        res += '/';
        res += path;
    }
    return (res == "") ? "/" : res;
}

void Shell::openingScreen(){
    std::cout << "*";
    for(int i = 0; i < 63; ++i)
        std::cout << "-";
    std::cout << "*\n";
    for(int i = 0; i < 29 ; ++i)
        std::cout << " ";
    std::cout << "MyShell\n";
    
    Shell::helpMenu();

    std::cout << "*";
    for(int i = 0; i < 63; ++i)
        std::cout << "-";
    std::cout << "*\n";
}

void Shell::helpMenu(){
    std::cout << "Commands:\n\n";
    std::cout << "ls : lists files in the current directory,\n"
              << "give -R as argument to use it recursively\n\n";
    std::cout << "mkdir |directoryName| : crates a directory named directoryName\n\n";
    std::cout << "rm |fileName| : deletes the file named fileName from the"
              << " current directory\n\n";
    std::cout << "cp |filePath| |fileName| : copies the file from the given path\n"
              << "to current directory, names it fileName\n\n";
    std::cout << "link |sourceFile| |linkName| : makes a soft link between the\n"
              << "source file and a link named linkName\n\n";
    std::cout << "cd |dirName| : changes the current directory to directory named dirName\n\n";
    std::cout << "cat |fileName| : prints the content of the file named fileName\n\n"; 
}

void Shell::initialize(){
    std::ifstream ifile;
    ifile.open("myShell.txt");

    if(!ifile.is_open())
        throw std::exception();

    int rootFileCount;
    ifile >> rootFileCount;
    ifile.get();

    initDir(ifile,&root,rootFileCount);

    ifile.close();
}

void Shell::saveShell()const{
    std::ofstream ofile;
    ofile.open("myShell.txt");

    if(!ofile.is_open())
        throw std::exception();

    ofile << root.fileCount() << "\n";
    writeDir(ofile,&root);

    ofile.close();
}

void Shell::initDir(std::istream& in,Directory* d, int fileCount, int ind){
    if(ind >= fileCount)
        return;

    char fileType;
    std::string fileName;
    std::time_t c_time;

    in >> fileType >> fileName >> c_time;
    if(fileType == 'F'){
        int byte;
        in >> byte;
        in.get();

        std::vector<char> _data;
        for(int i = 0; i < byte; ++i)
            _data.push_back(in.get());
        in.get();

        dataFile* newFile = new dataFile(fileName,_data,c_time);
        d->addContent(newFile);
        totalSize += newFile->getSize();
    }
    else if(fileType == 'L'){
        std::string _path;
        in >> _path;
        in.get();

        Link* newLink = new Link(fileName,_path,&root,c_time);
        d->addContent(newLink);
    }
    else if(fileType == 'D'){
        int newFileCount;
        in >> newFileCount;
        in.get();

        Directory* newDir = new Directory(fileName,d,c_time);
        initDir(in,newDir,newFileCount);
        d->addContent(newDir);
    }
    else
        throw std::exception();

    initDir(in,d,fileCount,++ind);
}

void Shell::writeDir(std::ostream& out,const Directory* d,int ind)const{
    if(ind >= d->fileCount())
        return;

    if(dynamic_cast<dataFile*>(d->at(ind)) != nullptr){ //If the file is a data file
        dataFile* temp = dynamic_cast<dataFile*>(d->at(ind));

        out << "F " << temp->getName() << " " << temp->getTime() << " " << temp->getSize() << "\n";
        temp->printContent(out);
        out << "\n";
    }
    else if(dynamic_cast<Link*>(d->at(ind)) != nullptr){ //If the file is a link
        Link* temp = dynamic_cast<Link*>(d->at(ind));

        out << "L " << temp->getName() << " " << temp->getTime() << " " << temp->getPath() << "\n";
    }
    else if(dynamic_cast<Directory*>(d->at(ind)) != nullptr){ //If the file is a directory
        Directory* temp = dynamic_cast<Directory*>(d->at(ind));

        out << "D " << temp->getName() << " " << temp->getTime()
            << " "  << temp->fileCount() << "\n";
        writeDir(out,temp);
    }
    else
        throw std::exception();

    writeDir(out,d,++ind);
}

void Shell::copyDir(Directory* target,Directory* source){
    File* newFile;
    for(int i = 0; i < source->fileCount(); ++i){
        if(dynamic_cast<dataFile*>(source->at(i))!=nullptr)
            newFile = new dataFile(*dynamic_cast<dataFile*>(source->at(i)));
        else if(dynamic_cast<Link*>(source->at(i))!=nullptr)
            newFile = new Link(*dynamic_cast<Link*>(source->at(i)));
        else{
            Directory* newD = new Directory(source->at(i)->getName(),target);
            copyDir(newD,dynamic_cast<Directory*>(source->at(i)));
            newFile = newD;
        }
        target->addContent(newFile);
    }
}

}//GTUFile
F shell.h 1704713791 1646
#ifndef SHELL_H
#define SHELL_H
#include "file.h"
#include <vector>
namespace GTUFile{

class Shell{
public:
    Shell();
    ~Shell();

    void Start();
private:
    Directory root;
    Directory* currentDir;
    int totalSize;

    /*Shell commands*/
    void mkdir(const std::vector<std::string>& input);
    void ls(const std::vector<std::string>& input)const;
    void cd(const std::vector<std::string>& input);
    void cp(const std::vector<std::string>& input);
    void cat(const std::vector<std::string>& input)const;
    void rm(const std::vector<std::string>& input);
    void link(const std::vector<std::string>& input);
    void pwd(const std::vector<std::string>& input)const;

    /*-----------------Helper Functions-----------------*/
    static void parseInput(std::vector<std::string>& v);
    /*Seperates the strings in given input, puts them into string vector*/

    void commandSeperator(const std::vector<std::string>& input);
    /*Calls the commands according to the given input*/

    void lsRecursive(const Directory* d,int depth = 0)const;
    static std::string nameFromPath(const std::string& path);
    std::string completePath(const std::string& path = "")const; 
    /*Non complete path: myDir2/myFile */
    /*Complete path: /myDir/myDir2/myFile  myDir is on the root*/

    static void openingScreen();
    static void helpMenu();
    void initialize();
    void saveShell()const;

    void writeDir(std::ostream& out,const Directory* d,int ind = 0)const;
    void initDir(std::istream& in,Directory* d, int fileCount, int ind = 0);
    void copyDir(Directory* target,Directory* source);
};

}//GTUFile

#endif
D chess 1704724809 3
F chessDriver.cpp 1704713504 134
#include <iostream>
#include "src/board.h"
#include "src/piece.h"

int main(){
    ChessBoard main;
    main.Start();
    return 0; 
}
F makefile 1704713509 65
all:
	g++ chessDriver.cpp -o out -O3 -std=c++11 src/*.cpp
	./out

D src 1704724809 4
F board.h 1704713574 3183
#ifndef BOARD_H
#define BOARD_H
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include "piece.h"
    
class ChessBoard{
public:
    ChessBoard();
    
    void Start();
private:
    /*Member Data*/
    std::vector<std::vector<Piece> > board;

    bool checkStatus; 
    /*Is true if the board is in a check situation, false if not*/

    Piece::Color Turn; 
    /*Color of the player who has the turn*/

    static const int defaultDepth;
    /*Depth the calculations will be made by suggest function*/

    int boardRSize; /*For later purposes*/
    int boardCSize;

    /*Member Functions*/
    void changeTurn(){Turn == Piece::Color::White ? Turn = Piece::Color::Black : Turn = Piece::Color::White;} 
    /*Sets the turn to the other player*/

    void initBoard(); /*Initializes the pieces on the board to correct values*/

    int Play();       /*Main function that starts the gameplay*/

    int move(std::vector<int> val); /*Main move function, returns the error code. Returns 0 if a move has been made*/

    void printBoard(std::ostream& out)const; /*Prints the board to given std::ostream*/

    static bool coordinateValues(std::string input,std::vector<int>& res); 
    /*Returns the coordinate indexes of the given input in a vector of ints*/

    static void notation(const std::vector<int> vec);
    /*Prints the given coordinate values in chess notation*/

    bool validateMove(const std::vector<int> values)const;
    /*Validates the move according to piece spesific rules*/

    void applyMove(int cRow,int cCol,int dRow,int dCol);
    /*Applies the validated move to the board*/

    static bool specialInputs(const std::string input); /*Checks if the given input is a special input*/
                                                        /*like: 0-0,0--0,suggest,save,load,forfeit etc.*/

    bool underAttack(const Piece& p)const;        /*True if given piece is under attack, false if not*/

    const Piece& findKing()const; 
    /*Returns the referance to king piece of the player who has the turn*/

    int calcPoint(Piece::Color T)const; /*Calculates the point of the board for the given color*/

    bool gameEnded()const; /*Returns true if there is a check mate*/

    std::vector<int> suggest(int depth)const;
    /*Calculates the best board according to the points, then returns the move thats leading up to it*/

    static void possibleBoards(std::vector<ChessBoard>& boards);
    /*calculates all of the possible moves from the initial boards at given vector*/
    /*pust them into the vector then deletes the initial boards*/

    void possibleMoves(std::vector<std::vector<int> >& moves)const;
    /*calculates all of the possible moves from the callers board and puts them in given vector*/

    static void playBestMove(ChessBoard& b); 
    /*Plays the best move for the given board at depth 1*/

    void loadBoard();                        /*Loads the board from the given filename*/
    void saveBoard()const;                   /*Saves the board to a file*/
    bool validateBoard()const;

    static void printMenu();
    static void errorCodes(int code);
    static void help();
};

#endif
F board.cpp 1704713578 18932
#include "board.h"
const int ChessBoard::defaultDepth = 3; /*Default depth for suggest functions calculations*/

ChessBoard::ChessBoard():board{
    {'R','N','B','Q','K','B','N','R'},
    {'P','P','P','P','P','P','P','P'},
    {'.','.','.','.','.','.','.','.'},
    {'.','.','.','.','.','.','.','.'},
    {'.','.','.','.','.','.','.','.'},
    {'.','.','.','.','.','.','.','.'},
    {'p','p','p','p','p','p','p','p'},
    {'r','n','b','q','k','b','n','r'}
}{
    initBoard();
    boardCSize = 8;
    boardRSize = 8;
}

void ChessBoard::initBoard(){
    for(int row = 0; row < 8; ++row){
        for(int col = 0; col < 8; ++col){
            board[row][col].setRow(row);
            board[row][col].setCol(col);
        }
    }

    for(int row = 0; row < 2; ++row)
        for(int col = 0; col < 8; ++col)
            board[row][col].setClr(Piece::Color::White);

    for(int row = 2; row < 6; ++row)
        for(int col = 0; col < 8; ++col)
            board[row][col].setClr(Piece::Color::Empty);

    for(int row = 6; row < 8; ++row)
        for(int col = 0; col < 8; ++col)
            board[row][col].setClr(Piece::Color::Black);

    Turn = Piece::Color::White;
    checkStatus = false;
}

void ChessBoard::Start(){
    bool session_ended = false;
    bool game_played = false;
    char input;
    std::cout << "WELCOME TO THE CHESS GAME\n\nGTU 241 HOMEWORK_1\n\nADIL MERT ERGORUN\n";
    do{
        if(game_played) *this = ChessBoard(); /*Sets the board to its default position if a game has been played on it*/
        ChessBoard::printMenu();
        input = std::cin.get();
        switch(input){
            case '1': std::cout << "!Type exit if you want to end the game, do not terminate the code in any other way!\n Good Luck!\n\n";
                    Play();
                    game_played = true;
                    session_ended = false;
                    break;
            case '2': loadBoard();
                    if(validateBoard()){
                        std::cout << "Board loaded succesfully! Good Luck!!\n\n";
                        Play();
                        game_played = true;
                        session_ended = false;
                    }
                    else{
                        std::cout << "Invalid board. Check if the filename is correct, or try another file.\n";
                        game_played = false;
                        session_ended = false;
                    }
                    break;
            case '3': ChessBoard::help();
                      game_played = false;
                      session_ended = false;
                    break;
            case '4': session_ended = true;
                      game_played = false;
                    break;
            default:std::cout << "Invalid input! Try again.\n";
                    session_ended = false;
                    game_played = false;
                    break;
        }
        while(std::cin.get() != '\n'); /*Clears the buffer*/
    }while(session_ended == false);
}

int ChessBoard::Play(){
    std::string in;
    std::vector<int> values;
    bool ended = false;
    bool moveMade = false;
    int msgCode;
    while(!ended){
        checkStatus = underAttack(findKing());
        
        if(checkStatus && gameEnded()){
            if(Turn == Piece::Color::White) std::cout << "Black Won!\n";
            else std::cout << "White Won!\n";
            ended = true;
            return 0;
        }
        else if(checkStatus) std::cout <<  "    !CHECK!    \n";

        printBoard(std::cout);

        do{
            if(Turn == Piece::Color::White)
                std::cout << "\n[White Players Turn]\n";
            else
                std::cout << "\n[Black Players Turn]\n";

            std::cin >> in;
            if(in == "suggest"){
                std::cout << "Calculating...\n";
                values = suggest(ChessBoard::defaultDepth);
                applyMove(values[0],values[1],values[2],values[3]);
                std::cout << "Suggestion: ";
                notation(values);
                moveMade = true;
                msgCode = 0;
            }
            else if(in == "save"){
                saveBoard();
                moveMade = false;
                msgCode = 0;
            }
            else if(in == "load"){
                loadBoard();
                if(validateBoard()){
                    std::cout << "Board loaded succesfully!\n";
                    printBoard(std::cout);
                    moveMade = false;
                    msgCode = 0;
                }
                else{
                    std::cout << "Invalid board. Exitting the game.\n\n";
                    ended = true;
                    return -1;
                }
            }
            else if(in == "exit"){
                std::cout << "Ending the game.\n";
                return 0;
            }
            else if(in == "help"){
                ChessBoard::help();
                moveMade = false;
                msgCode = 0;
            }
            else if(coordinateValues(in,values)){
                msgCode = move(values);
                if(msgCode==0) moveMade = true;
                else moveMade = false;
            }
            else{
                moveMade = false;
                msgCode = 1;
            }
            ChessBoard::errorCodes(msgCode);
        }while(moveMade == false);
        changeTurn();
    }
    return -1;
}

int ChessBoard::move(std::vector<int> values){
    for(int i = 0; i < 4; ++i){ /*Input must be in bounds of the board*/
        if(values[i] < 0 || values[i] > 7) return 2;
    }

    if(!validateMove(values)){ /*This part checks the move according to chess rules*/
        return 3;
    }

    int cRow = values[0], cCol = values[1];
    int dRow = values[2], dCol = values[3];

    applyMove(cRow,cCol,dRow,dCol);
    board[dRow][dCol].changeMoved();
    return 0;
}

bool ChessBoard::validateMove(const std::vector<int> values)const{
    int cRow = values[0], cCol = values[1];
    int dRow = values[2], dCol = values[3];
    if(Turn != board[cRow][cCol].getClr()) /*Checks if the player is moving its own*/
        return false;                      /*pieces or not*/  

    if(cRow == dRow && cCol == dCol)
        return false;             /*Current position and destination can't be same*/

    bool res = board[cRow][cCol].checkRules(board,dRow,dCol);

    Piece tempP;
    ChessBoard tempB = *this;
    bool isResultaCheck;
    if(res){
        tempP = board[dRow][dCol];
        tempB.applyMove(cRow,cCol,dRow,dCol);
        isResultaCheck = tempB.underAttack(tempB.findKing());
        if(isResultaCheck) res = false;
    }
    
    return res;
}

void ChessBoard::printBoard(std::ostream& out)const{
    for(int row = 7; row >= 0; --row){
        out << row+1 << " | ";
        for(int col = 0; col < 8; ++col)
            out << board[row][col].getType() << " ";

        out << "\n";
    }

    out << "    ";
    for(int i = 0; i < 15; ++i)
        out << "-";
    out << "\n";

    char files = 'a';
    out << "    ";
    for(int i = 0; i < 8; ++i){
        out << files << " ";
        ++files;
    }
    out << "\n";
}

void ChessBoard::loadBoard(){
    std::ifstream in;
    std::string filename;
    std::cout << "Filename to load the game: ";
    std::cin >> filename;
    in.open(filename);
    if(!in.is_open()){
        std::cout << "File couldn't be opened. Terminating the program.\n";
        exit(-1);
    }

    std::string turn;
    Piece::Color side;
    char ch;
    in >> turn;

    if(turn == "White") Turn = Piece::Color::White;
    else if(turn == "Black") Turn = Piece::Color::Black;
    else Turn = Piece::Color::Empty;

    in.get();
    for(int r = 7; r >= 0; --r){
        for(int i = 0; i < 4; ++i) in.get();
        for(int c = 0; c < 8; ++c){
            ch = in.get();
            in.get();
            if(ch == '.') side = Piece::Color::Empty;
            else if(isupper(ch)) side = Piece::Color::White;
            else side = Piece::Color::Black;
            board[r][c] = Piece(r,c,ch,side);
        }
        in.get();
    }

    in.close();
}

bool ChessBoard::validateBoard()const{
    ChessBoard temp = *this;
    bool check1,check2;
    check1 = temp.underAttack(findKing());
    temp.changeTurn();
    check2 = temp.underAttack(findKing());

    if(check1 && check2) return false;
    return true;
}

void ChessBoard::saveBoard()const{
    std::ofstream outFile;
    std::string file_name;
    std::cout << "File name to write: ";
    std::cin >> file_name;
    outFile.open(file_name);
    if(!outFile.is_open()){
        std::cout << "File couldn't be opened. Terminating the program.\n";
        exit(-1);
    }
    
    if(Turn == Piece::Color::White) outFile << "White\n";
    else outFile << "Black\n";
    printBoard(outFile);
    outFile.close();
    std::cout << "Board saved succesfully! You can continue your game.\n";
}

bool ChessBoard::coordinateValues(std::string input,std::vector<int>& res){
    bool valid= true;

    if(input.length()!=4)
        valid = false;

    if(!isalpha(input[0]) || !isdigit(input[1]) || !isalpha(input[2]) || !isdigit(input[3]))
        valid = false;             /*This parts checks if the input is in the desired notation*/

    if(valid == false) return false;
    
    res.clear();
    res.push_back(input[1] - '0' - 1); /*Current Row index*/
    res.push_back(input[0] - 97);      /*Current Collumn index*/

    res.push_back(input[3] - '0' - 1); /*Destination Row index*/
    res.push_back(input[2] - 97);      /*Destination Collumn index*/
    return valid;
}

void ChessBoard::notation(const std::vector<int> vec){
    char cCol = vec[1] + 97;
    char cRow = vec[0] + '0' + 1;
    char dCol = vec[3] + 97;
    char dRow = vec[2] + '0' + 1;
    std::cout << cCol << cRow << dCol << dRow << "\n";
}  

bool ChessBoard::underAttack(const Piece& p)const{
    int cRow = p.getRow(), cCol = p.getCol();

    int row,col;
    for(row = 0; row < 8; ++row){
        for(col = 0; col < 8; ++col){
            if(board[row][col].getClr() != p.getClr()){
                if(p.RpieceRule(board,row,col) && (board[row][col].getType() == 'r' || board[row][col].getType() == 'R'||
                                                   board[row][col].getType() == 'q' || board[row][col].getType() == 'Q'))
                    return true;
                else if(p.BpieceRule(board,row,col) && (board[row][col].getType() == 'b' || board[row][col].getType() == 'B'||
                                                        board[row][col].getType() == 'q' || board[row][col].getType() == 'Q'))
                    return true;
                else if(p.NpieceRule(board,row,col) && (board[row][col].getType() == 'n' || board[row][col].getType() == 'N'))
                    return true;
                else if(row == cRow+1 && (col == cCol-1 || col == cCol+1) && board[row][col].getType() == 'p')
                    return true;
                else if(row == cRow-1 && (col == cCol-1 || col == cCol+1) && board[row][col].getType() == 'P')
                    return true;
            }
        }
    }
    return false;
}

void ChessBoard::applyMove(int cRow,int cCol,int dRow,int dCol){
    board[dRow][dCol] = board[cRow][cCol];
    board[dRow][dCol].setCol(dCol);
    board[dRow][dCol].setRow(dRow);
    board[cRow][cCol] = Piece(cRow,cCol);
}

const Piece& ChessBoard::findKing()const{
    for(int row = 0; row < 8; ++row){
        for(int col = 0; col < 8; ++col){
            if((board[row][col].getType() == 'K' && Turn == Piece::Color::White)||(board[row][col].getType() == 'k' && Turn == Piece::Color::Black))
                return board[row][col];
        }
    }
    std::cout << "\n!!There is no king of given color in at the board, terminating the program.\n";
    exit(-1); 
}

int ChessBoard::calcPoint(Piece::Color T)const{
    double totalP = 0.0,p;
    for(int r = 0; r < 8; ++r){
        for(int c = 0; c < 8; ++c){
            p = board[r][c].piecePoint();    

            if(underAttack(board[r][c])) p = p/2;

            if(board[r][c].getClr() == T) totalP += p;
            else totalP -= p;
        }
    }
    return totalP;
}

bool ChessBoard::gameEnded()const{
    int row,col,mRow,mCol;
    ChessBoard temp = *this;

    for(row = 0; row < 8; ++row){
        for(col = 0; col < 8; ++col){
            if(temp.board[row][col].getClr() == temp.Turn){
                for(mRow = 0; mRow < 8; ++mRow){
                    for(mCol = 0; mCol < 8; ++mCol){
                        if(temp.validateMove({row,col,mRow,mCol})) return false;
                    }
                }
            }
        }
    }
    return true;
}

bool ChessBoard::specialInputs(const std::string in){
    return false;
}

std::vector<int> ChessBoard::suggest(int depth)const{
    std::vector<ChessBoard> firstBoards; /*firstBoards holds all of the possible moves after 1 move*/

    std::vector<ChessBoard> laterBoards; /*laterBoards holds all of the possible boards of given depth for*/
                                         /*one of the possible first moves*/
    std::vector<std::vector<int> > firstMoves;  /*firstMoves holds all of the possible first moves*/
    firstBoards.push_back(*this);
    
    firstBoards[0].possibleMoves(firstMoves); 
    ChessBoard::possibleBoards(firstBoards); /*possibleBoards takes a board vector which already has at least one board in it. Function */
                                             /*generates all of the possible boards (at given depth) from the initial boards at the vector*/
                                             /*and puts the generated boards to the vector. Function then erases the initial boards*/
    int fBoardNum = firstBoards.size();

    int bestMoveIndex=0;
    double currentScore,bestScore;
    bool mated_board;

    for(int i = 0; i < fBoardNum; ++i) if(firstBoards[i].gameEnded()) return firstMoves[i];
    /*This part checks for mate in ones.*/

    double loadBarCount = static_cast<double>(fBoardNum);
    for(int i = 0; i < fBoardNum; ++i){
        laterBoards.clear();
        laterBoards.push_back(firstBoards[i]);
        mated_board = false;
        for(int j = 1; j < depth; ++j){
            for(int k = 0; k < laterBoards.size(); ++k){ /*This part checks if there is a mated board in the vector*/
                if(laterBoards[k].gameEnded()){          /*If that is the case, program doesn't try to calculate the boards for more depths*/
                    mated_board = true;
                    j = depth;
                }
            }
            if(mated_board == false){
                for(int k = 0; k < laterBoards.size(); ++k){ ChessBoard::playBestMove(laterBoards[k]);} /*playBestMove plays the best move for the opponent,*/
                possibleBoards(laterBoards);                                                            /*which is basically a depth 1 suggestion in our case*/
            }
        }

        if(i==0 && laterBoards.size()!=0){ 
                        /*Score can be negative, so initializing the bestScore with a value would be a bad design choice*/
                        /*Instead, bestScore starts with the first of the generated boards score*/
                bestScore = laterBoards[0].calcPoint(Turn);
                bestMoveIndex = i;
        }
        for(int j = 0; j < laterBoards.size(); ++j){
            currentScore = laterBoards[j].calcPoint(Turn);
            if(currentScore > bestScore){
                bestScore = currentScore;
                bestMoveIndex = i;
            }
        }
    }

    return firstMoves[bestMoveIndex];
}

void ChessBoard::possibleBoards(std::vector<ChessBoard>& boards){
    int row,col,mRow,mCol;
    int fSize = boards.size();
    ChessBoard temp;
    Piece tempP;
    for(int i = 0; i < fSize; ++i){
        temp = boards[i];
        for(row = 0; row < 8; ++row){
            for(col = 0; col < 8; ++col){
                for(mRow = 0; mRow < 8; ++mRow){
                    for(mCol = 0; mCol < 8; ++mCol){
                        if(temp.validateMove({row,col,mRow,mCol})){
                            tempP = temp.board[mRow][mCol];
                            temp.applyMove(row,col,mRow,mCol);
                            temp.changeTurn();
                            boards.push_back(temp);
                            temp.applyMove(mRow,mCol,row,col);
                            temp.board[mRow][mCol] = tempP;
                            temp.changeTurn();
                        }
                    }
                }
            }
        }
    }

    for(int i = 0; i < fSize; ++i) boards.erase(boards.begin());
}
void ChessBoard::possibleMoves(std::vector<std::vector<int> >& moves)const{
    int row,col,mRow,mCol;
    for(row = 0; row < 8; ++row){
        for(col = 0; col < 8; ++col){
            for(mRow = 0; mRow < 8; ++mRow){
                for(mCol = 0; mCol < 8; ++mCol){
                    if(validateMove({row,col,mRow,mCol})) moves.push_back({row,col,mRow,mCol});
                }
            }
        }
    }
}

void ChessBoard::playBestMove(ChessBoard& b){
    std::vector<ChessBoard> firstBoards;
    std::vector<std::vector<int> > firstMoves;
    firstBoards.push_back(b);
    
    b.possibleMoves(firstMoves);
    ChessBoard::possibleBoards(firstBoards);
    int fBoardNum = firstBoards.size();

    int bestMoveIndex=0,currentScore,bestScore=-1;
    for(int i = 0; i < fBoardNum; ++i){
        currentScore = firstBoards[i].calcPoint(b.Turn);
        if(currentScore > bestScore){
            bestScore = currentScore;
            bestMoveIndex = i;
        }
    }

    int cRow = firstMoves[bestMoveIndex].at(0),cCol = firstMoves[bestMoveIndex].at(1);
    int dRow = firstMoves[bestMoveIndex].at(2),dCol = firstMoves[bestMoveIndex].at(3);
    b.applyMove(cRow,cCol,dRow,dCol);
    b.changeTurn();
}

void ChessBoard::printMenu(){
    std::cout << "\n(1) Play!\n";
    std::cout << "(2) Load a game!\n";
    std::cout << "(3) Help\n";
    std::cout << "(4) Exit.\n";
    std::cout << "> ";
}

void ChessBoard::errorCodes(int code){
    switch(code){
        case 0: break;
        case 1: std::cout << "Non valid input! Try again.\n";
            break;
        case 2: std::cout << "Input is out of bounds!\n";
            break;
        case 3: std::cout << "Chess rules doesn't allow that!\n";
            break;
        default:std::cout << "Invalid.\n";
    }
}

void ChessBoard::help(){
    std::cout << "Commands you can write during the game \n\n";
    std::cout << "suggest : finds the best move for the player who \n"
              <<  "has the turn at default depth (3) and plays it\n\n";
    std::cout << "save : saves the game to a file\n\n";
    std::cout << "load : loads a board from a file\n\n";
    std::cout << "exit : ends the game and returns to the main menu\n\n";
    std::cout << "help : prints out this menu of commands\n";
}

F piece.h 1704713589 2135
#ifndef PIECE_H
#define PIECE_H
#include <iostream>
#include <cstdlib>
#include <iomanip>
#include <vector>

class Piece{
public:
    enum class Color {
        White = 'w',
        Black = 'b',
        Empty = 'e'
    };

    Piece():cCol(0),cRow(0),type('.'),hasMoved(false),color(Piece::Color::Empty){/*Left blank intentionally*/}
    /*Initializes a null piece at row->0 and collumn->0*/

    Piece(char t); 
    /*Initializes a piece with given type at coordinates 0,0*/

    Piece(int r,int c); 
    /*Initializes a null piece at row->r and collumn->c*/

    Piece(int row, int col, char type, Piece::Color clr);

    void setCol(int num);
    void setRow(int num);
    int getCol()const{ return cCol;}
    int getRow()const{ return cRow;}
    void setClr(Color clr){color = clr;}
    void changeMoved(){ hasMoved = true;}
    Color getClr()const{ return color;}
    char getType()const{ return type;}

    bool checkRules(const std::vector<std::vector<Piece> >& board,int dRow,int dCol)const;

    /*Piece spesific rulesets*/
    bool PpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    bool NpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    bool BpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    bool RpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    bool QpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    bool KpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const;  
    

    /*Obstacle functions checks whether or not piece can move to said coorditanes according to pieces ruleset*/
    /*There was no need for a Pawn,Knight ,Queen or King obstacle function*/
    bool Bobstacle(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const; 
    bool Robstacle(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const; 

    int piecePoint()const; /*Returns the point of the piece*/
    
private:
    int cCol, cRow;
    char type;
    bool hasMoved;

    Color color;
};

#endif
F piece.cpp 1704713595 6283
#include "piece.h"

Piece::Piece(int row, int col, char tp, Piece::Color clr){
    setCol(col);
    setRow(row);
    type = tp;
    color = clr;
    hasMoved = false;
}

Piece::Piece(int r,int c){
    setCol(c);
    setRow(r);
    type = '.';
    color = Color::Empty;
    hasMoved = false;
}

Piece::Piece(char t){
    if(!isalpha(t) && t != '.')
        exit(-1);
    
    type = t;
    hasMoved = false;
}

void Piece::setCol(int num){
        if(num < 0 || num > 7)
            exit(-1);
        cCol = num;
}

void Piece::setRow(int num){
        if(num < 0 || num > 7)
            exit(-1);
        cRow = num;
}

int Piece::piecePoint()const{
    switch(type){       
        case 'R':
        case 'r': return 5;

        case 'N':
        case 'n': return 3;

        case 'B':
        case 'b': return 3;

        case 'Q':
        case 'q':  return 9;

        case 'K':
        case 'k': return 0;

        case 'P':
        case 'p': return 1;
        
        default: return 0;
    }
    return 0;
}

bool Piece::checkRules(const std::vector<std::vector<Piece> >& board,int dRow,int dCol)const{
    if(dRow > 7 || dRow < 0 || dCol > 7 || dCol < 0)             /*In bound check*/
        return false;
    if(color == board[dRow][dCol].getClr()) /*Same color pieces can't take each other*/
        return false;

    bool res = false;
    switch(type){       /*Piece spesific checks*/
        case 'R':
        case 'r': res = RpieceRule(board, dRow, dCol);
            break;

        case 'N':
        case 'n': res = NpieceRule(board, dRow, dCol);
            break;

        case 'B':
        case 'b': res = BpieceRule(board, dRow, dCol);
            break;

        case 'Q':
        case 'q': res = QpieceRule(board, dRow, dCol);
            break;

        case 'K':
        case 'k': res = KpieceRule(board, dRow, dCol);
            break;

        case 'P':
        case 'p': res = PpieceRule(board, dRow, dCol);
            break;
        
        default: break;
    }
    return res;
}

/*Piece spesific ruleset function definitions*/

bool Piece::RpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    bool res=false;
    if(dRow - cRow == 0 || dCol - cCol == 0)
        res = true;

    return res && Robstacle(board,dRow,dCol);
}

bool Piece::Robstacle(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    int i;
    if(dRow - cRow == 0 && dCol > cCol){
        for(i = cCol+1; i < dCol; ++i){
            if(board[cRow][i].getType() != '.')
                return false;
        }
    }
    if(dRow - cRow == 0 && dCol < cCol){
        for(i = cCol-1; i > dCol; --i){
            if(board[cRow][i].getType() != '.')
                return false;
        }
    }
    if(dCol - cCol == 0 && dRow > cRow){
        for(i = cRow+1; i < dRow; ++i){
            if(board[i][cCol].getType() != '.')
                return false;
        }
    }
    if(dCol - cCol == 0 && dRow < cRow){
        for(i = cRow-1; i > dRow; --i){
            if(board[i][cCol].getType() != '.')
                return false;
        }
    }
    return true;
}

bool Piece::NpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    if((dRow == cRow+2 && (dCol == cCol+1 || dCol == cCol-1)) || (dRow == cRow-2 && (dCol == cCol + 1 || dCol == cCol -1)) ||
       (dCol == cCol+2 && (dRow == cRow+1 || dRow == cRow-1)) || (dCol == cCol-2 && (dRow == cRow + 1 || dRow == cRow -1)))
        return true;

    return false;
}
//There was no need for a Knight obstacle function

bool Piece::BpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    bool res = false;
    if(abs(dRow - cRow) == abs(dCol - cCol))
        res = true;

    return res && Bobstacle(board,dRow,dCol);
}

bool Piece::Bobstacle(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    int i;
    if(dRow > cRow && dCol > cCol){
        for(i = 1; i < dRow-cRow; ++i){
            if(board[cRow+i][cCol+i].getType() != '.')
                return false;
        }
    }
    if(dRow > cRow && dCol < cCol){
        for(i = 1; i < dRow-cRow; ++i){
            if(board[cRow+i][cCol-i].getType() != '.')
                return false;
        }
    }
    if(dRow < cRow && dCol > cCol){
        for(i = 1; i < dCol-cCol; ++i){
            if(board[cRow-i][cCol+i].getType() != '.')
                return false;
        }
    }
    if(dRow < cRow && dCol < cCol){
        for(i = 1; i < cCol - dCol; ++i){
            if(board[cRow-i][cCol-i].getType() != '.')
                return false;
        }
    }
    return true;
}

bool Piece::QpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    bool Rrule = RpieceRule(board,dRow,dCol),Brule = BpieceRule(board,dRow,dCol);
    bool res = Rrule || Brule;

    return Rrule==true ? res && Robstacle(board,dRow,dCol) : res && Bobstacle(board,dRow,dCol);
}
//Queen obstacle function uses either Rooks or Bishops obstacle function, thus there was no need of writing one

bool Piece::KpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{
    if(abs(dRow-cRow)<=1 && abs(dCol-cCol)<=1)
        return true;

    return false;
}
//There was no need for a King obstacle function

bool Piece::PpieceRule(const std::vector<std::vector<Piece> >& board,int dRow, int dCol)const{ 
    bool res;
    if(color == Piece::Color::White){
        if(dCol == cCol){
            if(dRow - cRow == 1 && board[dRow][dCol].getType() == '.') return true;
            else if(dRow - cRow == 2 && cRow == 1 && board[dRow-1][dCol].getType() == '.' && board[dRow][dCol].getType() == '.') return true;
        }
        else if(abs(dCol - cCol) == 1 && dRow - cRow==1 && board[dRow][dCol].getClr()==Piece::Color::Black) return true;
    }
    else{
        if(dCol == cCol){
            if(cRow - dRow == 1 && board[dRow][dCol].getType() == '.') return true;
            else if(cRow - dRow == 2 && cRow == 6 && board[dRow+1][dCol].getType() == '.' && board[dRow][dCol].getType() == '.') return true;
        }
        else if(abs(dCol - cCol) == 1 && cRow - dRow==1 && board[dRow][dCol].getClr()==Piece::Color::White) return true;
    }

    return false;
}
//There was no need for a pawn obstacle function
L source 1704724854 /chess/src
F readme 1704817239 644
Commands:

ls : lists files in the current directory,
give -R as argument to use it recursively

mkdir |directoryName| : crates a directory named directoryName

rm |fileName| : deletes the file named fileName from the current directory

cp |filePath| |fileName| : copies the file from the given path
to current directory, names it fileName. If fileName is . then
the name will be taken from the copied file.

link |sourceFile| |linkName| : makes a soft link between the
source file and a link named linkName

cd |dirName| : changes the current directory to directory named dirName

cat |fileName| : prints the content of the file named fileName
